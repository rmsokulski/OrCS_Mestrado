HAS_HIVE = 0;
HAS_VIMA = 1;

//===========PIPELINE STAGES===========
FETCH_WIDTH = 4;
DECODE_WIDTH = 4;
RENAME_WIDTH = 4;
DISPATCH_WIDTH = 8; // Um por FU?
EXECUTE_WIDTH = 8; // Um por FU?
COMMIT_WIDTH = 8; // Diz que é assíncrono, então seria algo bem alto? Vou repetir o de cima

FETCH_LATENCY = 4;
DECODE_LATENCY = 1;
RENAME_LATENCY = 1; // Coloquei aqui a latência de dispatch
DISPATCH_LATENCY = 1; // Coloquei aqui a latência de issue
EXECUTE_LATENCY = 1;
COMMIT_LATENCY = 1; // Apenas para liberar apenas no próximo ciclo, no fim ele apenas usaria nesse próximo mesmo..
//===========PIPELINE STAGES===========
//=======PROCESSOR BUFFERS SIZE========
FETCH_BUFFER = 32;
DECODE_BUFFER = 32; // Não tem, então vou deixar igual ao de fetch
RAT_SIZE = 257; // 128 FP + 128 INT + 1 Dependências entre uops
ROB_SIZE = 128;
UNIFIED_RS = 96; // 32 FP + 32 INT + 32 MEM
//=======PROCESSOR BUFFERS SIZE========
//=========MEMORY BUFFERS SIZE=========
MOB_READ = 32;
MOB_WRITE = 32;
MOB_VIMA = 32; // Só para deixar igual / padronizado
//=========MEMORY BUFFERS SIZE=========
//========MEMORY DESAMBIGUATION========
// Mantive do Skylake
LOAD_HASH_SIZE = 512;
STORE_HASH_SIZE = 512;
DESAMBIGUATION_BLOCK_SIZE = 4;
ADDRESS_TO_ADDRESS = 1;
REGISTER_FORWARD = 1;
//========MEMORY DESAMBIGUATION========
//=======INTEGER FUNCTIONAL UNITS======
 // Mantive do Skylake
LATENCY_INTEGER_ALU = 1;
LATENCY_BRANCH = 1; // Antigo INTEGER_ALU, que só era usado em branches
WAIT_NEXT_INT_ALU = 1;
INTEGER_ALU = 4;

LATENCY_INTEGER_MUL = 3;
WAIT_NEXT_INT_MUL = 1;
INTEGER_MUL = 1;

LATENCY_INTEGER_DIV = 32;
WAIT_NEXT_INT_DIV = 32;
INTEGER_DIV = 1;
//=======INTEGER FUNCTIONAL UNITS======
//===FLOATING POINT FUNCTIONAL UNITS===
// Mantive do Skylake
//FLOATING POINT DIV
LATENCY_FP_DIV = 10;
WAIT_NEXT_FP_DIV = 10;
FP_DIV = 1;

LATENCY_FP_MUL = 5;
WAIT_NEXT_FP_MUL = 1;
FP_MUL = 2;

LATENCY_FP_ALU = 3;
WAIT_NEXT_FP_ALU = 1;
FP_ALU = 2;
//===FLOATING POINT FUNCTIONAL UNITS====
//=======MEMORY FUNCTIONAL UNITS========
// LOAD e STORE de acordo com o BOOM
LOAD_UNIT = 2;
WAIT_NEXT_MEM_LOAD = 1;
LATENCY_MEM_LOAD = 1;

STORE_UNIT = 1;
WAIT_NEXT_MEM_STORE = 1;
LATENCY_MEM_STORE = 1;

// Aqui só mantive
VIMA_UNIT = 1;
WAIT_NEXT_MEM_VIMA = 1;
LATENCY_MEM_VIMA = 1;

DISAMBIGUATION_ENABLED = 1;
DISAMBIGUATION_METHOD = "HASHED";

PARALLEL_LOADS = 1;
PARALLEL_STORES = 1;
//=======MEMORY FUNCTIONAL UNITS========
//===========BRANCH PREDICTOR===========
BTB_ENTRIES = 4096;
BTB_WAYS = 4;

BRANCH_PREDICTION_METHOD = "PIECEWISE";

BTB_MISS_PENALITY = 5;
MISSPREDICTION_PENALITY = 8;
N = 128;
M = 128;
H = 43;
//===========BRANCH PREDICTOR===========
//=================DEBUG================
DEBUG = 0;
PROCESSOR_DEBUG = 0;
FETCH_DEBUG = 0;
DECODE_DEBUG = 0;
RENAME_DEBUG = 0;
DISPATCH_DEBUG = 0;
EXECUTE_DEBUG = 0;
COMMIT_DEBUG = 0;
MEMORY_DEBUG = 0;
WAIT_CYCLE = 0;
//=================DEBUG================
